# React Hooks

This document provides a summary of React hooks, including their descriptions and example usages.

## React Hooks Overview

| Hook                        | Description                                                                                              | Example Code                                                                                                        |
|-----------------------------|----------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------|
| **`useState`**              | Manages state in functional components.                                                                  | `import React, { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}

export default Counter;
` |
| **`useEffect`**             | Runs side effects (e.g., data fetching, subscriptions) in functional components.                        | `jsx<br>import React, { useEffect, useState } from 'react';<br><br>function DataFetcher() {<br>  const [data, setData] = useState(null);<br>  useEffect(() => {<br>    fetch('https://api.example.com/data')<br>      .then(response => response.json())<br>      .then(data => setData(data));<br>  }, []);<br>  return (<br>    <div>{data ? <p>{data}</p> : <p>Loading...</p>}</div><br>  );<br>}<br>export default DataFetcher;<br>` |
| **`useContext`**            | Accesses context values from a React Context.                                                            | `jsx<br>import React, { useContext } from 'react';<br><br>const ThemeContext = React.createContext('light');<br><br>function ThemedComponent() {<br>  const theme = useContext(ThemeContext);<br>  return (<br>    <div>The theme is {theme}</div><br>  );<br>}<br>export default ThemedComponent;<br>` |
| **`useReducer`**            | An alternative to `useState` for managing complex state logic.                                          | `jsx<br>import React, { useReducer } from 'react';<br><br>const initialState = { count: 0 };<br>function reducer(state, action) {<br>  switch (action.type) {<br>    case 'increment':<br>      return { count: state.count + 1 };<br>    case 'decrement':<br>      return { count: state.count - 1 };<br>    default:<br>      throw new Error();<br>  }<br>}<br><br>function Counter() {<br>  const [state, dispatch] = useReducer(reducer, initialState);<br>  return (<br>    <div><br>      <p>Count: {state.count}</p><br>      <button onClick={() => dispatch({ type: 'increment' })}>Increment</button><br>      <button onClick={() => dispatch({ type: 'decrement' })}>Decrement</button><br>    </div><br>  );<br>}<br>export default Counter;<br>` |
| **`useCallback`**           | Memoizes a callback function to prevent unnecessary re-creations on each render.                        | `jsx<br>import React, { useCallback, useState } from 'react';<br><br>function ExpensiveComponent({ onClick }) {<br>  return (<br>    <button onClick={onClick}>Click me</button><br>  );<br>}<br><br>function ParentComponent() {<br>  const [count, setCount] = useState(0);<br>  const handleClick = useCallback(() => {<br>    console.log('Button clicked');<br>  }, []);<br>  return (<br>    <div><br>      <ExpensiveComponent onClick={handleClick} /><br>      <p>Count: {count}</p><br>      <button onClick={() => setCount(count + 1)}>Increment</button><br>    </div><br>  );<br>}<br>export default ParentComponent;<br>` |
| **`useMemo`**               | Memoizes the result of a computation to optimize performance.                                           | `jsx<br>import React, { useMemo, useState } from 'react';<br><br>function ExpensiveComponent({ value }) {<br>  const computedValue = useMemo(() => {<br>    // Expensive computation<br>    return value * 2;<br>  }, [value]);<br>  return (<br>    <div>Computed Value: {computedValue}</div><br>  );<br>}<br><br>function ParentComponent() {<br>  const [value, setValue] = useState(1);<br>  return (<br>    <div><br>      <ExpensiveComponent value={value} /><br>      <button onClick={() => setValue(value + 1)}>Increment</button><br>    </div><br>  );<br>}<br>export default ParentComponent;<br>` |
| **`useRef`**                | Creates a mutable object that persists across renders; often used for accessing DOM elements.          | `jsx<br>import React, { useRef } from 'react';<br><br>function FocusInput() {<br>  const inputRef = useRef(null);<br>  const focusInput = () => {<br>    inputRef.current.focus();<br>  };<br>  return (<br>    <div><br>      <input ref={inputRef} type="text" /><br>      <button onClick={focusInput}>Focus the input</button><br>    </div><br>  );<br>}<br>export default FocusInput;<br>` |
| **`useImperativeHandle`**   | Customizes the instance value that is exposed when using `ref` with `forwardRef`.                        | `jsx<br>import React, { forwardRef, useImperativeHandle, useRef } from 'react';<br><br>const FancyInput = forwardRef((props, ref) => {<br>  const inputRef = useRef(null);<br>  useImperativeHandle(ref, () => ({<br>    focus: () => {<br>      inputRef.current.focus();<br>    },<br>  }));<br>  return (<br>    <input ref={inputRef} {...props} /><br>  );<br>});<br><br>function ParentComponent() {<br>  const ref = useRef(null);<br>  const handleClick = () => {<br>    ref.current.focus();<br>  };<br>  return (<br>    <div><br>      <FancyInput ref={ref} /><br>      <button onClick={handleClick}>Focus Input</button><br>    </div><br>  );<br>}<br>export default ParentComponent;<br>` |
| **`useLayoutEffect`**       | Similar to `useEffect`, but fires synchronously after all DOM mutations.                              | `jsx<br>import React, { useLayoutEffect, useRef, useState } from 'react';<br><br>function LayoutEffectExample() {<br>  const [height, setHeight] = useState(0);<br>  const divRef = useRef(null);<br>  useLayoutEffect(() => {<br>    setHeight(divRef.current.getBoundingClientRect().height);<br>  });<br>  return (<br>    <div ref={divRef}><br>      <p>Height: {height}px</p><br>    </div><br>  );<br>}<br>export default LayoutEffectExample;<br>` |
| **`useDebugValue`**         | Displays a label for custom hooks in React DevTools.                                                  | `jsx<br>import { useDebugValue, useState } from 'react';<br><br>function useCustomHook(value) {<br>  useDebugValue(value ? 'Value Present' : 'No Value');<br>  // Custom hook logic<br>}<br><br>function Component() {<br>  useCustomHook(true);<br>  return <div>Check React DevTools for custom hook debug value.</div>;<br>}<br>` |
| **`useTransition`**         | Manages state transitions with a pending state to handle complex state updates gracefully.            | `jsx<br>import React, { useState, useTransition } from 'react';<br><br>function TransitionExample() {<br>  const [isPending, startTransition] = useTransition();<br>  const [count, setCount] = useState(0);<br>  const handleClick = () => {<br>    startTransition(() => {<br>      setCount(count + 1);<br>    });<br>  };<br>  return (<br>    <div><br>      <button onClick={handleClick} disabled={isPending}>Increment</button><br>      <p>Count: {count}</p><br>    </div><br>  );<br>}<br>export default TransitionExample;<br>` |
| **`useDeferredValue`**      | Delays the update of a value until after a render to improve the responsiveness of the UI.             | `jsx<br>import React, { useState, useDeferredValue } from 'react';<br><br>function DeferredValueExample() {<br>  const [input, setInput] = useState('');<br>  const deferredInput = useDeferredValue(input);<br>  return (<br>    <div><br>      <input value={input} onChange={(e) => setInput(e.target.value)} /><br>      <p>Deferred Value: {deferredInput}</p><br>    </div><br>  );<br>}<br>export default DeferredValueExample;<br>` |
| **`useId`**                | Generates unique IDs for accessibility attributes and elements in components.                          | `jsx<br>import React, { useId } from 'react';<br><br>function UniqueIdComponent() {<br>  const id = useId();<br>  return (<br>    <div><br>      <label htmlFor={id}>Label</label><br>      <input id={id} type="text" /><br>    </div><br>  );<br>}<br>export default UniqueIdComponent;<br>` |
| **`useSyncExternalStore`**  | Subscribes to an external store and syncs its state with the component.                                 | `jsx<br>import React, { useSyncExternalStore } from 'react';<br><br>function useExternalStore(subscribe, getSnapshot) {<br>  return useSyncExternalStore(subscribe, getSnapshot);<br>}<br><br>function ExternalStoreExample() {<br>  const state = useExternalStore(() => {/* subscribe logic */}, () => {/* get snapshot */});<br>  return <div>External Store State: {state}</div>;<br>}<br>export default ExternalStoreExample;<br>` |
| **`usePrevious`**          | Custom hook to keep track of the previous value of a state or prop.                                    | `jsx<br>import { useRef, useEffect } from 'react';<br><br>function usePrevious(value) {<br>  const ref = useRef();<br>  useEffect(() => {<br>    ref.current = value;<br>  }, [value]);<br>  return ref.current;<br>}<br><br>function PreviousValueExample() {<br>  const [count, setCount] = useState(0);<br>  const prevCount = usePrevious(count);<br>  return (<br>    <div><br>      <p>Count: {count}</p><br>      <p>Previous Count: {prevCount}</p><br>      <button onClick={() => setCount(count + 1)}>Increment</button><br>    </div><br>  );<br>}<br>export default PreviousValueExample;<br>` |
| **`useUpdateEffect`**      | Custom hook that behaves like `useEffect` but does not run on the initial render.                       | `jsx<br>import { useEffect, useRef } from 'react';<br><br>function useUpdateEffect(effect, deps) {<br>  const hasMounted = useRef(false);<br>  useEffect(() => {<br>    if (hasMounted.current) {<br>      effect();<br>    } else {<br>      hasMounted.current = true;<br>    }<br>  }, deps);<br>}<br><br>function UpdateEffectExample() {<br>  const [count, setCount] = useState(0);<br>  useUpdateEffect(() => {<br>    console.log('Count updated:', count);<br>  }, [count]);<br>  return (<br>    <div><br>      <p>Count: {count}</p><br>      <button onClick={() => setCount(count + 1)}>Increment</button><br>    </div><br>  );<br>}<br>export default UpdateEffectExample;<br>` |
| **`useFetch`**             | Custom hook for handling data fetching.                                                                 | `jsx<br>import { useState, useEffect } from 'react';<br><br>function useFetch(url) {<br>  const [data, setData] = useState(null);<br>  const [loading, setLoading] = useState(true);<br>  const [error, setError] = useState(null);<br><br>  useEffect(() => {<br>    fetch(url)<br>      .then(response => response.json())<br>      .then(data => {<br>        setData(data);<br>        setLoading(false);<br>      })<br>      .catch(error => {<br>        setError(error);<br>        setLoading(false);<br>      });<br>  }, [url]);<br><br>  return { data, loading, error };<br>}<br><br>function FetchExample() {<br>  const { data, loading, error } = useFetch('https://api.example.com/data');<br>  if (loading) return <p>Loading...</p>;<br>  if (error) return <p>Error: {error.message}</p>;<br>  return <div>{JSON.stringify(data)}</div>;<br>}<br>export default FetchExample;<br>` |
| **`useLocalStorage`**      | Custom hook for synchronizing state with `localStorage`.                                                | `jsx<br>import { useState } from 'react';<br><br>function useLocalStorage(key, initialValue) {<br>  const [storedValue, setStoredValue] = useState(() => {<br>    try {<br>      const item = window.localStorage.getItem(key);<br>      return item ? JSON.parse(item) : initialValue;<br>    } catch (error) {<br>      return initialValue;<br>    }<br>  });<br><br>  const setValue = value => {<br>    try {<br>      const valueToStore = value instanceof Function ? value(storedValue) : value;<br>      setStoredValue(valueToStore);<br>      window.localStorage.setItem(key, JSON.stringify(valueToStore));<br>    } catch (error) {<br>      console.error(error);<br>    }<br>  };<br><br>  return [storedValue, setValue];<br>}<br><br>function LocalStorageExample() {<br>  const [name, setName] = useLocalStorage('name', '');<br>  return (<br>    <div><br>      <input value={name} onChange={(e) => setName(e.target.value)} /><br>      <p>Stored Name: {name}</p><br>    </div><br>  );<br>}<br>export default LocalStorageExample;<br>` |
